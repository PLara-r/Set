# Set (далее дженерики)
1) SetИнтерфейс

не добавляет никаких дополнительных методов , которые вы должны знать для экзамена.
Вам просто нужно знать, как наборы ведут себя по отношению к традиционным Collectionметодам. 
Вы также должны знать различия между типами наборов. Давайте начнем с HashSet:
3:    Set<Integer> set = new HashSet<>();
4:    boolean b1 = set.add(66);                                   // true
5:    boolean b2 = set.add(10);                                   // true
6:    boolean b3 = set.add(66);                                   // false
7:    boolean b4 = set.add(8);                                    // true
8:    for (Integer integer: set) System.out.print(integer + ","); // 66,8,10,
Эти add()методы должны быть простыми. Они возвращаются, trueесли они уже не Integerнаходятся в наборе.
Строка 6 возвращается false, потому что у нас уже есть 66 в наборе, и набор должен сохранить уникальность. 
В строке 8 печатаются элементы множества в произвольном порядке. В этом случае это не порядок сортировки или порядок добавления элементов.
Помните, что equals()метод используется для определения равенства. Этот hashCode()метод используется для определения того, в каком сегменте искать,
так чтобы Java не приходилось просматривать весь набор, чтобы выяснить, есть ли там объект. 
В лучшем случае хеш-коды уникальны, и Java должна вызывать equals()только один объект.
В худшем случае все реализации возвращают одно hashCode()и то же , и equals()в любом случае Java должна вызывать каждый элемент набора.
Теперь давайте посмотрим на тот же пример с TreeSet:
3:    Set<Integer> set = new HashSet<>();
4:    boolean b1 = set.add(66);                                    // true
5:    boolean b2 = set.add(10);                                    // true
6:    boolean b3 = set.add(66);                                    // false
7:    boolean b4 = set.add(8);                                     // true
8:    for (Integer integer: set) System.out.print(integer + ",");  // 8,10,66
На этот раз элементы распечатываются в естественном порядке. Числа реализуют Comparableинтерфейс в Java, который используется для сортировки.
  
  2)Дженерики
  Обобщения являются параметрами типа для кода. Чтобы создать класс с универсальным параметром, добавьте <T>после имени класса. Вы можете использовать любое имя для параметра типа. Одиночные заглавные буквы являются распространенным выбором.
Оператор diamond ( <>) используется, чтобы сообщить Java, что универсальный тип соответствует объявлению, не указывая его снова. Оператор diamond может использоваться для локальных переменных или переменных экземпляра, а также для однострочных объявлений.
Обобщения позволяют указывать подстановочные знаки. <?>это неограниченный шаблон, который означает любой тип. <? extends Object>верхняя граница, которая означает любой тип, который является Objectили расширяет его. <? extends MyInterface>означает любой тип, который реализует MyInterface. <? super Number>является нижней границей, которая означает любой тип Numberили суперкласс. Ошибка компилятора возникает из-за кода, который пытается добавить или удалить элемент в списке с неограниченным или верхним ограниченным подстановочным знаком.

  
    Собираем все вместе
    
На данный момент вы знаете все, что вам нужно знать, чтобы сдать экзаменационные вопросы по дженерикам. Можно объединить эти понятия, чтобы написать действительно запутанный код, который любит делать экзамен.
Этот раздел будет трудно читать. Он содержит самые трудные вопросы, которые вы могли бы задать о дженериках. Вопросы на экзамене, вероятно, будет легче читать, чем эти. Мы хотим, чтобы вы встретились с действительно сложными, чтобы вы были готовы к экзамену. Другими словами, не паникуйте. Не торопитесь, и перечитайте код несколько раз. Вы получите это.
Давайте попробуем пример. Сначала мы объявляем три класса, которые будет использовать пример:
class A {}
class B extends A { }
class C extends B { }

Готов? Вы можете выяснить, почему они делают или не компилируют? Кроме того, попытайтесь выяснить, что они делают.
6:    List<?> list1 = new ArrayList<A>();
7:    List<? extends A> list2 = new ArrayList<A>();
8:    List<? super A> list3 = new ArrayList<A>();
9:    List<? extends B> list4 = new ArrayList<A>();   // DOES NOT COMPILE
10:   List<? super B> list5 = new ArrayList<A>();
11:   List<?> list6 = new ArrayList<? extends A>();  // DOES NOT COMPILE
Строка 6 создает объект, ArrayListкоторый может содержать экземпляры класса A. Он хранится в переменной с неограниченным подстановочным знаком. На любой универсальный тип можно ссылаться из неограниченного подстановочного знака, что делает это нормально.
Строка 7 пытается сохранить список в объявлении переменной с ограниченным сверху символом подстановки. Хорошо. Вы можете иметь ArrayList<A>, ArrayList<B>или ArrayList<C> хранить в этой ссылке. Строка 8 тоже в порядке. На этот раз у вас есть ограниченный снизу символ подстановки. Самый низкий тип, на который вы можете ссылаться A. Поскольку это то, что у вас есть, оно компилируется.
Строка 9 имеет ограниченный сверху символ подстановки, который позволяет ArrayList<B>или ArrayList<C>на него можно сослаться. Так как у вас есть на ArrayList<A>что пытаются ссылаться, код не компилируется. Линия 10 имеет нижний ограниченный групповой символ, который позволяет ссылку на ArrayList<A>, ArrayList<B>или ArrayList<Object>.
Наконец, строка 11 допускает ссылку на любой универсальный тип, поскольку он является неограниченным подстановочным знаком. Проблема в том, что вам нужно знать, что это будет за тип при создании экземпляра ArrayList. В любом случае это было бы бесполезно, потому что вы не можете добавить к этому никаких элементов ArrayList.
Теперь о методах. Тот же вопрос: попытайтесь выяснить, почему они не компилируются и что они делают. Мы представим методы по одному, потому что есть над чем подумать.

<T> T method1(List<? extends T> list) {  
 return list.get(0);
}
method1()это совершенно нормальное использование дженериков. Он использует специфичный для метода параметр типа T. Он принимает параметр List<T>или некоторый подкласс Tи возвращает единственный объект этого Tтипа. Например, вы можете вызвать его с List<String>параметром и вернуть String. Или вы можете вызвать его с List<Number>параметром и вернуть Number. Или ... ну, вы поняли.
Учитывая это, вы должны увидеть, что не так с этим:
<T> <? extends T> method2(List<? extends T> list) {  // DOES NOT COMPILE 
  return list.get(0);
}

method2()не компилируется, потому что возвращаемый тип на самом деле не является типом. Вы пишете метод. Вы знаете, какой тип он должен вернуть. Вы не можете указать это как шаблон.
Теперь будьте осторожны - это очень сложно:
<B extends A> B method3(List<B> list) { 
   return new B();   // DOES NOT COMPILE
}
method3()не компилируется. <B extends A>говорит, что вы хотите использовать Bв качестве параметра типа только для этого метода и что ему нужно расширить Aкласс. По совпадению, Bэто также название класса. Это не совпадение. Это злой трюк. В рамках этого метода, В может представлять классы A, Bили C, потому что все расширить Aкласс. Поскольку B больше не ссылается на Bкласс в методе, вы не можете создать его экземпляр.
После этого было бы неплохо получить что-то прямое:
void method4(List<? super B> list) {
}
method4()это обычное использование дженериков. Вы можете передать типы List<B>, List<A>или List<Object>.
И, наконец, наш последний вопрос для вас:
<X> void method5(List<X super B> list) {   // DOES NOT COMPILE
}
method5()не компилируется, потому что пытается смешать параметр типа конкретного метода с подстановочным знаком. Подстановочный знак должен иметь ?в нем.
Мы рады сообщить вам, что остальная часть главы намного проще. Мы также рады сообщить вам, что в остальной части главы используются только основы дженериков. Ну, по крайней мере, пока вы не дойдете до обзора вопросов. Это означает, что вы можете продолжить читать оставшуюся часть этой главы и вернуться, чтобы перечитать раздел об общих чертах завтра, когда у вас будет свежий ум. 

